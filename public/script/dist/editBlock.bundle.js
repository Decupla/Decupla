/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./public/script/editBlock/editBlock.js":
/*!**********************************************!*\
  !*** ./public/script/editBlock/editBlock.js ***!
  \**********************************************/
/***/ (() => {

eval("\n\n(() => {\n\n    // === DOM & VARS ===\n    const DOM = {};\n    DOM.blockForm = document.querySelector('form#createBlock');\n    DOM.addInputButton = document.querySelector('button#addInput');\n    DOM.inputPopupWrapper = document.querySelector('#inputPopupWrapper');\n    DOM.inputForm = document.querySelector('#addInputForm');\n    DOM.fieldsArea = document.querySelector('#inputFields');\n    DOM.messageSuccess = document.querySelector('#message-success');\n\n    DOM.inputFormFields = {};\n    DOM.inputFormFields.type = DOM.inputForm.querySelector('select#type');\n    DOM.inputFormFields.name = DOM.inputForm.querySelector('input#name');\n    DOM.inputFormFields.label = DOM.inputForm.querySelector('input#label');\n    DOM.inputFormFields.maxLength = DOM.inputForm.querySelector('input#maxLength');\n\n    DOM.fieldMessages = {};\n    DOM.fieldMessages.title = DOM.blockForm.querySelector('#message-title');\n    DOM.fieldMessages.type = DOM.inputForm.querySelector('#message-type');\n    DOM.fieldMessages.name = DOM.inputForm.querySelector('#message-name');\n    DOM.fieldMessages.label = DOM.inputForm.querySelector('#message-label');\n    DOM.fieldMessages.maxLength = DOM.inputForm.querySelector('#message-maxLength');\n\n    const inputData = [];\n\n    let inputMethod = \"create\";\n    // the id of the input in the inputData array we are editing at the moment\n    let inputID;\n    // used for the inputData array. Basically the better index. Not used for the database!\n    let nextInputId = 1;\n    // tells if we are editing a existing block\n    let blocksExists;\n    // if we are editing a existing block, the id of the block will be stored here\n    let blockID;\n\n    // === INIT =========\n\n    const init = async () => {\n        const path = window.location.pathname;\n        blocksExists = checkIfExists(path);\n\n        if (blocksExists) {\n            blockID = getId(path);\n            await getInputData(blockID);\n\n            if (inputData.length > 0) {\n                nextInputId = inputData[inputData.length - 1].id + 1;\n            }\n        }\n\n        setupBlockForm();\n    };\n\n\n    // === EVENTS & XHR =======\n    //handles the event when the main form (block) is submitted\n    const handleBlockSubmit = async (event) => {\n        event.preventDefault();\n        const formData = new FormData(event.target);\n        const data = Object.fromEntries(formData.entries());\n\n        if (data.title === \"\") {\n            setFieldMessage('title', '\"Title\" is required');\n            return;\n        }\n\n        data.input = JSON.stringify(inputData);\n\n        let method = \"POST\"\n        let url = \"/blocks\";\n\n        // if we are editing a existing block, we need a different method and url\n        if (blocksExists) {\n            method = \"PUT\";\n            url = `/blocks/${blockID}`;\n        }\n\n        try {\n            const response = await fetch(url, {\n                method,\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(data)\n            });\n            const responseData = await response.json(); // Antwort als JSON parsen\n\n            if (!response.ok) {\n                throw new Error(`HTTP Error: ${response.status}`);\n            }\n\n            if (responseData.success) {\n                DOM.messageSuccess.classList.add('visible');\n\n                if (!blocksExists && 'newID' in responseData) {\n                    blocksExists = true;\n                    blockID = responseData.newID;\n                } else if (!blocksExists) {\n                    console.error('could not get id of the created block')\n                }\n\n            } else {\n                console.error('Something went wrong while trying to save the block');\n            }\n        } catch (error) {\n            console.error('Something went wrong:', error);\n        }\n    }\n\n    // called when the input form is submitted\n    const handleInputSubmit = (event) => {\n        event.preventDefault();\n        const formData = new FormData(event.target);\n        const data = Object.fromEntries(formData.entries());\n        if (inputMethod === \"create\") {\n            saveNewInput(data);\n        } else if (inputMethod === \"update\") {\n            updateInput(data);\n        } else {\n            console.log('No input method was given.');\n        }\n    }\n\n    // called when the type of a input is changed while creating / editing input\n    const handleTypeChange = (type) => {\n        switch (type) {\n            case 'shortText':\n                setVisible(['name', 'label', 'type', 'maxLength']);\n                break;\n            case 'LongText':\n                setVisible(['name', 'label', 'type']);\n                break;\n            default:\n                setVisible(['name', 'label', 'type']);\n        }\n    }\n\n    // === FUNCTIONS ====\n    // saves new input to the inputData array\n    const saveNewInput = (data) => {\n        if (!validate(data, true)) return;\n        data.id = nextInputId++;\n        inputData.push(data);\n        addInputVisualization(data);\n        toggleInputPopup();\n        DOM.inputForm.reset();\n    };\n\n    // updates existing input in the inputData array\n    const updateInput = (data) => {\n        const index = inputData.findIndex(input => input.id === inputID);\n        if (index === -1 || inputID === 0) {\n            console.error('The data of the input field could not be found.');\n            return;\n        }\n\n        if (inputData[index].name !== data.name) {\n            if (!validate(data, true)) return;\n        } else if (!validate(data)) {\n            return;\n        }\n\n        data.id = inputID;\n        inputData[index] = data;\n        updateInputVisualization(inputID, data);\n        toggleInputPopup();\n        DOM.inputForm.reset();\n    };\n\n    // deletes existing input from the inputData array\n    const deleteInput = (id) => {\n        const index = inputData.findIndex(input => input.id === id);\n\n        if (index !== -1) {\n            // remove input from the array\n            inputData.splice(index, 1);\n            // delete the visualization\n            deleteInputVisualization(id);\n\n        }\n    }\n\n    const setupBlockForm = () => {\n        // sets all event listeners needed to interact with the block creation\n        DOM.addInputButton.addEventListener('click', createInput);\n        DOM.inputForm.addEventListener('submit', handleInputSubmit);\n        DOM.blockForm.addEventListener('submit', handleBlockSubmit);\n        DOM.inputFormFields.type.addEventListener('change', (event) => {\n            handleTypeChange(event.target.value);\n        });\n    };\n\n\n    // get the existing input fields of the block\n    const getInputData = async (id) => {\n        try {\n            const response = await fetch(`/blocks/${id}`);\n            const blockData = await response.json();\n            if (blockData.success === true) {\n                const input = JSON.parse(blockData.block.input);\n                inputData.push(...input);\n\n                inputData.forEach((data) => {\n                    addInputVisualization(data);\n                });\n\n            } else {\n                // to do: fehlermeldung auf der Seite ausgebe\n                console.log(blockData.message);\n            }\n        } catch (error) {\n            console.error('Something went wrong:', error);\n        }\n    };\n\n    // opens the input form to create a new input\n    const createInput = () => {\n        inputMethod = \"create\";\n        handleTypeChange(DOM.inputForm.type.value);\n        toggleInputPopup();\n    }\n\n    // opens the input form to edit a existing input from the inputData array\n    const editInput = (id) => {\n        inputMethod = \"update\";\n\n        const data = inputData.find(input => input.id === id) || null;\n        if (data === null) {\n            console.log('Input to edit could not be found.');\n            return;\n        }\n        DOM.inputFormFields.type.value = data.type;\n        DOM.inputFormFields.name.value = data.name;\n        DOM.inputFormFields.label.value = data.label;\n\n        if ('maxLength' in data) {\n            DOM.inputFormFields.maxLength.value = data.maxLength;\n        }\n\n        inputID = id;\n        handleTypeChange(data.type);\n        toggleInputPopup();\n    }\n\n    // sets which settings should be visible in the input creation, hides all other settings\n    const setVisible = (fields) => {\n        for (const [name, element] of Object.entries(DOM.inputFormFields)) {\n            const parent = element.parentElement;\n            if (fields.includes(name) && !parent.classList.contains('visible')) {\n                parent.classList.add('visible');\n            } else if (!fields.includes(name) && parent.classList.contains('visible')) {\n                parent.classList.remove('visible');\n            }\n        }\n    }\n\n    // adds the visualization of a input to the page\n    const addInputVisualization = (data) => {\n        const input = document.createElement('div');\n        const inputTitle = document.createElement('h3');\n        const inputParams = document.createElement('div');\n        const editButton = document.createElement('button');\n        const deleteButton = document.createElement('button');\n\n        input.classList.add('inputVis');\n        inputTitle.classList.add('label');\n        inputParams.classList.add('params');\n        editButton.classList.add('edit');\n        deleteButton.classList.add('delete');\n\n        inputTitle.innerText = data.label;\n        editButton.innerText = \"edit\";\n        deleteButton.innerText = \"delete\";\n\n        input.dataset.id = data.id;\n\n        Object.entries(data).forEach(([key, value]) => {\n            if (key !== 'label' && key !== 'id' && value !== \"\") {\n                const param = `<strong>${key}</strong>: ${value}<br>`;\n                inputParams.innerHTML += param;\n            }\n        });\n\n        input.appendChild(inputTitle);\n        input.appendChild(inputParams);\n        input.appendChild(editButton);\n        input.appendChild(deleteButton);\n        DOM.fieldsArea.appendChild(input);\n\n        editButton.addEventListener('click', () => {\n            editInput(data.id);\n        });\n        deleteButton.addEventListener('click', () => {\n            deleteInput(data.id);\n        })\n    }\n\n    // updates a exisiting visualization of a input\n    const updateInputVisualization = (id, data) => {\n        const vis = document.querySelector(`.inputVis[data-id=\"${id}\"]`);\n        const inputTitle = vis.querySelector('h3');\n        const inputParams = vis.querySelector('.params');\n\n        inputTitle.innerText = data.label;\n\n\n        inputParams.innerHTML = \"\";\n\n        Object.entries(data).forEach(([key, value]) => {\n            if (key !== 'label' && key !== 'id' && value !== \"\") {\n                const param = `<strong>${key}</strong>: ${value}<br>`;\n                inputParams.innerHTML += param;\n            }\n        });\n    }\n\n    // deletes a exisiting visualization of a input\n    const deleteInputVisualization = (id) => {\n        const vis = document.querySelector(`.inputVis[data-id=\"${id}\"]`);\n        vis.remove();\n    }\n\n    const toggleInputPopup = () => {\n        DOM.inputPopupWrapper.classList.toggle('visible');\n    }\n\n    // sets a message for a specific field in the block or input form\n    const setFieldMessage = (field, message) => {\n        const fieldMessageElement = DOM.fieldMessages[field];\n        if (fieldMessageElement) {\n            fieldMessageElement.innerText = message;\n        } else {\n            console.log(`Field \"${field}\" does not exist.`);\n        }\n    };\n\n    //check if the name of a input already exists\n    const nameExists = (name) => {\n        return inputData.some(obj => obj.name === name);\n    }\n\n    //validate input data\n    const validate = (data, newName = false) => {\n        let isValid = true;\n\n        for (const [name, element] of Object.entries(DOM.fieldMessages)) {\n            element.innerText = \"\";\n        }\n\n        if (!data.name) {\n            setFieldMessage('name', '\"name\" is required.');\n            isValid = false;\n        }\n        if (data.name.includes(\" \")) {\n            setFieldMessage('name', '\"name\" cannot contain spaces.')\n            isValid = false;\n        }\n        if (!data.label) {\n            setFieldMessage('label', '\"label\" is required.');\n            isValid = false;\n        }\n        if (newName && nameExists(data.name)) {\n            setFieldMessage('name', `Input with name \"${data.name}\" already exists`);\n            isValid = false;\n        }\n\n        return isValid;\n    };\n\n\n    // checks if we are creating a new block or editing a existing block\n    const checkIfExists = (path) => {\n        const regex = /^\\/blocks\\/edit\\/(\\d+)$/;\n        return path.match(regex);\n    }\n\n    const getId = (path) => {\n        const parts = path.split(\"/\");\n        const id = parts[parts.length - 1];\n        return parseInt(id);\n    }\n\n    init();\n\n})();\n\n//# sourceURL=webpack://decupla/./public/script/editBlock/editBlock.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./public/script/editBlock/editBlock.js"]();
/******/ 	
/******/ })()
;